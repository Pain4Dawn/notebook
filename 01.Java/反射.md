# 类加载

+ static 为类级别参数，可以在类加载时得到初始化，无法调用对象方法，对象方法可以调用类方法。
+ 类生命周期为：加载、验证、准备、解析、初始化、使用、卸载。加载使用类加载器。验证、准备、解析
+ 加载为静态数据换成方法区的数据结构
+ 生成类对象这个时机不确定，由jvm自己判定（如何保证其加载完后，执行）
+ jvm对class文件采用按需加载方式，当需要使用该类时，jvm才会将它的class文件加载到内存中产生class对象
+ 类对象放到堆中
+ 在准备阶段，初始化类变量（static）为默认值放到方法区
+ 初始化：类的初始化，是对类的static操作操作，具体初始化时机有：new，调用类内的静态方法，反射，虚拟机启动时，先初始化main方法所在的类等
+ 不会初始化的是：
  + 调用父类属性，子类不会初始化
  + 数组定义类引用
  + 引用常量不会触发初始化
+ 常量：final标注的，放到常量池中，每个类有自己的常量池，不会被重写。
+ 类加载器：主要是将class文件字节码加载到内存中，并将这些静态数据转换成方法区的运行数据，然后在堆中生成一个代表这个类的java.lang.Class的对象，作为方法区中类数据的访问入口。
+ 类加载器种类：
  + 引导类加载器，用C++编写，是JVM自带的类加载器，负责Java平台核心库，无法直接获取。rt.jar
  + 扩展类加载器：负责jre/lib/ext目录下的jar包 或 -D java.ext.dirs 指定目录下的jar包工作库
  + 系统类加载器：负责java -classpath 或 -D java.class.path所指的目录下的类与jar包装入工作，是最常用的加载器。
+ 双亲委派机制：现有父类加载器加载，如果没有下放给子加载器。
+ 反向委派机制：对于SPI服务，属于JAVA的核心库，但还需要加载第三方库，这样需要利用线程上下文类加载器逆向使用。

![](https://raw.githubusercontent.com/Pain4Dawn/notebook/master/98.picture/%E5%8F%8D%E5%90%91%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png)

[jvm类加载器，类加载机制详解，看这一篇就够了 - SegmentFault 思否](https://segmentfault.com/a/1190000037574626)

[(38条消息) JVM类生命周期概述：加载时机与加载过程_Rico's Blogs-CSDN博客_类加载时机](https://blog.csdn.net/justloveyou_/article/details/72466105)