# 基础

> 包只能声明全局变量，无法执行函数
>
> sync.WaitGroup 会与启动的协程比较，如果协程数小于waitgroup数则会死锁
>
> sync.WaitGroup 函数传值时，是值拷贝，不会生效
>
> 定义管道后，需要使用make来初始化，否则空指针
>
> 定义值后，一定要初始化后在defer，defer不会影响后面的赋值情况，造成空指针
>
> for select 跳出for循环，需要打标签EXIT： 后break跳到指定位置
>
> 结构体绑定函数，指针绑定，传输值为指针，结构体绑定函数，传输值为结构体，这个使用接口时需要注意，如果指针绑定，则传给接口时要是指针，接口都需要传递指针
>
> chan关闭，select case会一直输出，只不过值为默认值，第二个参数判定是否关闭
>
> map线程不安全的，同步读没有问题，读写有问题。
>
> 对象断言：系统只有interface类型才可以断言
>
> delve:dlv golang语言debug工具
>
> channel：环形队列，有两个队列协程，当有数据会唤醒。closed为标识，置换后不能进只能读。对于channel的关闭。
>
> + 写端关闭close
>
> + 使用Once关闭管道
>
> + 使用ctx.Done()
>
> + 使用comm ok写法
>
>   [(80 条消息) Go语言中如何检测一个channel已经被关闭了？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/450188866/answer/1790314327)
>
> 指针方法与值方法：为值拷贝，指针拷贝指针。值是对值做拷贝
>
> continue 跳出本次循环内容，执行下一个内容，包括for range channel

## string结构

string指针+字节数。string数据存储为只读内存，不支持改写

## slice结构

数据指针 + 数组长度 + 数组容量

append数组大于数组容量，重新开辟空间

## map结构

## 内存对齐

根据计算机字长，为提高内存读取效率，确保尽量一次读到所需的内存，规定字段类型存放的大小及位置。其中大小是根据计算机字长，按照其整除或倍数来确定每个字段类型长度。内存位置，根据自身字段长度及字长存放，确保尽量放到一个字长上去。对自身长度与字长取模，为偏移量。



## reflect

## 函数调用

+ 函数调用在内存中由虚拟调用栈，代码端组成。
+ 虚拟调用栈由栈基地址，局部变量，返回值，参数，返回值，参数在栈基前
+ 寄存器：BP（栈基地址寄存器），SP（栈帧地址寄存器），IP（指令寄存器），AX（返回结果值地址寄存器）
+ 根据IP指令，操作SP改变局部变量，返回值，参数的值。
+ 函数调用
  + call ret两个函数
  + cal函数主要功能：
    + 保存返回地址指令
    + IP指令跳转到被调用函数
  + 被调用函数执行：
    + 修改栈基BP
    + 修改SP指针到最大处
    + 执行指令
    + 修改栈基到调用者
    + 修改SP到调用者最大处
  + ret函数主要功能
    + 弹出call指令的返回地址
    + 跳转到指令地址

## 闭包及结构体绑定函数调用

+ 闭包定义：函数外部定义但在函数内部引用的自由变量，脱离了捕捉时的上下文，它也能照常运行。及在执行函数栈运行时跳出函数栈。
+ 返回值为函数为FunctionValue结构体，
+ 捕获列表-主要保证捕获变量与外部函数变量一致：
  + 被捕的自由变量没有被修改：拷贝值到捕获列表
  + 被修改：
    + 局部变量：捕获的自由变量存到堆中，funcValue的捕获变量的指针指向堆变量
    + 修改被捕获为参数：参数拷贝到堆中，捕获变量指针执行堆中
    + 为返回值：返回值拷贝到堆中，捕获变量的指针指向堆中的值，执行完成后，堆的值拷贝会返回值。
+ 结构体绑定函数，编译器转化语法糖，绑定结构体传递为第一个参数。
+ 由于参数传递为值拷贝，所以如果不是指针，会造成拷贝一份结构体，而没有达到修改。



